[{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/cloud-build/","title":"Cloud Build"},{"content":"","href":"/tags/cloud-functions/","title":"Cloud Functions"},{"content":"","href":"/tags/cloud-storage/","title":"Cloud Storage"},{"content":"GCPサービスの1つ、Cloud BuildはいわゆるCI/CDツールです。 GithubなどGitレポジトリに紐づけてトリガーさせて使うのが普通だと思います。トリガーとしても現状、リポジトリ経由しか選択できません。\nしかし、業務のある都合でCloud Storage経由でデプロイしたいことがありまして。 やり方を模索してみてうまくいったので、メモっておきます。\nソース 今回使ったものすべてこちらに置いてます。\nabekoh/gcp-deploy-from-storage\n全体像 今回はhello-funcというファンクションを、tar.gzに圧縮したソースからCloud Functionsにデプロイするというシナリオとします。 デプロイ対象はApp Engineとか、別のサービスでもいけると思います。\nデプロイ対象 シンプルにHTTPリクエストおくるとHelloが返ってくるFunctionです。Node.jsで書きます。\n// index.js exports.hello = (req, res) =\u0026gt; { res.send(\u0026#39;Hello, world!\u0026#39;); } これと、npm initで生成したpackage.jsonを含んだhello-func.tar.gzを作っておきます。\ntar zcvf hello-func.tar.gz index.js package.json ビルドファンクション実装 メインとなるビルド用ファンクションです。\nStorageのイベントをトリガーとして発火させ、Cloud BuildのAPIを叩いてビルド、デプロイを実行します。\nNode.js用のGoogle APIクライアントとして、普通はこちらを使いますが\ngooglespis/google-api-nodejs-client\nREADMEにも書かれている通り、GCP上で利用する場合は下記のライブラリのほうが使い勝手いいみたいです。\ngoogleapis/google-cloud-node\nCloud Buildの依存を追加します。\nnpm init npm i -S @google-cloud/cloudbuild ビルド用Functionsの実装はこちら。\n// index.js \u0026#39;use strict\u0026#39;; const {CloudBuildClient} = require(\u0026#39;@google-cloud/cloudbuild\u0026#39;); exports.build = async file =\u0026gt; { // file.metageneration: メタ情報が更新されるとインクリメントされる値  // ファイル自体が更新されるときは\u0026#39;1\u0026#39;となる  if (file.metageneration !== \u0026#39;1\u0026#39;) { return; } // Promiseを返却することで、解決させてfunctionsが終了する  return new CloudBuildClient().createBuild({ projectId: process.env.GCP_PROJECT_ID, build: { source: { storageSource: { // バケット名  bucket: file.bucket, // ファイル名  object: file.name } }, steps: [ { \u0026#34;name\u0026#34;: \u0026#34;gcr.io/cloud-builders/gcloud\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;functions\u0026#34;, \u0026#34;deploy\u0026#34;, \u0026#34;hello-func\u0026#34;, \u0026#34;--entry-point=hello\u0026#34;, \u0026#34;--runtime=nodejs10\u0026#34;, \u0026#34;--memory=128MB\u0026#34;, \u0026#34;--region=us-central1\u0026#34;, \u0026#34;--trigger-http\u0026#34; ] } ] } }); }; createBuildというメソッドで、任意のオプションからCloud Buildを起動させます。 このリクエスト内ではリポジトリだけでなくCloud Storageを指定することでき、今回やりたかったことが達成できます。\nまた、リクエストにプロジェクトIDを含める必要があります。 Node.js 8系までは GCP_PROJECT という環境変数で取得できたようですが、Node.js 10系では取得できなくなったようです。\n環境変数の使用 | Google Cloud Functions に関するドキュメント\n仕方ないので、デプロイ時のコマンドラインで指定することにしました。 以下のコマンドでbuild-funcをデプロイします。\ngcloud functions deploy build-func \\  --entry-point=build \\  --runtime=nodejs10 \\  --memory=256MB \\  --region=us-central1 \\  --trigger-bucket=src-func \\  --set-env-vars GCP_PRJECT_ID={GCPプロジェクト名} --trigger-bucketには、デプロイしたいファイルを置くバケットを指定します。\nCloud Buildの権限設定 Cloud Buildを使って対象を初めてデプロイする場合、権限設定が必要です。 今回はCloud Functionsをデプロイするのでその開発者と、サービスアカウントユーザーが必要なので付与します。\n動作確認 準備が整ったところで、Storageの対象バケットにアップロードしてみます。\ngsutil cp hello-func.tar.gz gs://src-func/hello-func.tar.gz このように、正常hello-funcがデプロイされました。\nまとめ ちょっと面倒ではありますが、ちょっと工夫するだけで実現できたので良かったです。 こんな感じで、トリガーに設定できなくてもAPIが存在すればFunctionsでなんとかなるってことは他にもあるかもですね。\n","href":"/post/gcp-deploy-functions-from-storage/","title":"Cloud Storage経由でCloud Buildを動かしてデプロイする"},{"content":"","href":"/tags/gcp/","title":"GCP"},{"content":"","href":"/tags/java/","title":"Java"},{"content":"","href":"/tags/javascript/","title":"JavaScript"},{"content":"","href":"/tags/node.js/","title":"Node.js"},{"content":"","href":"/post/","title":"Posts"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/categories/tech/","title":"tech"},{"content":"Oreillyから出てる『開眼！ JavaScript ――言語仕様から学ぶJavaScriptの本質』の読書メモです。\nhttps://www.oreilly.co.jp/books/9784873116211/\n仕事でもWebフロントアプリを触ることがあるものの、既存のコードを雰囲気で改修する程度で、今ひとつJSの挙動など理解できていなかったのでその辺りが知りたく。 ちょうどこの本が「JavaScript特有の癖、落とし穴」にフォーカスを当てていて、大変参考になりました。\n以下、刺さったところの個人的メモ。\nJSは基本なんでもオブジェクト、プリミティブでもオブジェクトのように扱える number, string, boolean, null, undefinedはプリミティブ、他はすべてオブジェクト扱い。 Array、Functionも結局Objectを着色したようなイメージ。\nプリミティブであっても、それに対応するラッパーオブジェクト(numberならNumber)のプロパティ、メソッドが呼び出せる。呼び出したとき、そのときだけオブジェクトを生成→破棄という流れになる。\n\u0026#39;hoge\u0026#39;.length // -\u0026gt; 4 JSのオブジェクトはミュータブル、基本なんでも挙動変えられる Arrayなどネイティブコンストラクタを持つオブジェクトであっても、windowなどグローバルオブジェクトであっても、そのプロパティ・メソッドは書き換え可能。 window.alert()でも書き換えて機能停止させることも可能。varつけずfoo = 'bar'とやればグローバルオブジェクトのプロパティをいじったことになる。\nもちろん、可能なだけで破壊的な変更は推奨されない。\nthisはそれを呼び出すタイミングで指すものが決まる var foo = \u0026#39;foo\u0026#39;; var myObject = { foo: \u0026#39;I am myObject.foo\u0026#39; }; var sayFoo = function() { console.log(this[\u0026#39;foo\u0026#39;]); }; // myObjectのsayFooメソッドにsayFoo()関数を与える myObject.sayFoo = sayFoo; myObject.sayFoo(); // myObject.sayFoo()内でのthisはmyObjectなので\u0026#39;I am myObject.foo\u0026#39;を出力 sayFoo(); // sayFoo()内でのthisはグローバルオブジェクトなので\u0026#39;foo\u0026#39;を出力 (P.87より引用)\n定義時の\u0026rsquo;foo'が常に出ると予想されるかもだが、実際は実行時のコンテキストに依存する。\n無名関数の即時実行 (function(){ console.log(\u0026#39;hoge\u0026#39;); })() functionの中身を即実行する書き方。 何度かこんなコードみたことあったのに、意味理解できていなかった。。\n関数の巻き上げ function後ろのほうで定義、前のほうで実行でも問題なし。\nfoo() // -\u0026gt; hoge function foo() { console.log(\u0026#39;hoge\u0026#39;); } これを関数の巻き上げと呼ぶ。JS特有ですね。 関数内で外側の変数つかってたりすると引っかかりそう。 (参考: やっとわかったjsの「巻き上げ」 - Qiita)\nコンストラクタのprototypeはインスタンスでは__proto__で参照できる Chrome Developer Toolsでオブジェクトについてる__proto__プロパティ、正体はそれを生成したコンストラクタのprototypeへの参照でした。 要するに、myObj.__proto__とmyObj.constructor.prototypeは同じものを指す。\nこの仕様は標準ではないらしい、けれど殆どのブラウザで機能している。\nnumberのラッパーオブジェクトのメソッド呼び出し 本文に直接無い内容だけど、自分理解のため。 数字をカンマ区切りにするとき、toLocalString()が使えるけど実際どう呼び出すんだろって色々ためすと\n10000.toLocalString() // -\u0026gt; エラー '10000'.toLocalString() // -\u0026gt; '10000' 10000..toLocaleString() // -\u0026gt; '10,000' (10000).toLocaleString() // '10,000' Number(10000).toLocaleString() // -\u0026gt; '10,000' new Number(10000).toLocaleString() // -\u0026gt; '10,000' var a = 10000 a.toLocaleString() // -\u0026gt; '10,000' という具合。10000.toLocalString()だと数値として評価できていない。 3行目の..となるのは、最初のドットは小数点として評価されるため。\nその他  プロトタイプチェーンについて図も使ってかなりじっくり解説されてわかりやすかった。ブログにまとめるの大変なので割愛。\n(Web記事だとこちらがわかりやすそう: や\u0026hellip;やっと理解できた！JavaScriptのプロトタイプチェーン) 便利ライブラリとしてUnderscore.jsが紹介されているが、今だとLodashのほうが主流かな？ Math.PIといった定数は変更不可。円周率3にできたりしない。  感想 他にも色々へぇ〜となるポイントだらけでした。業務だとTypeScriptだけど、こういう癖をうまく吸収したりしてくれて助かっている反面、やっぱりきちんと理解しておかないと詰まりそうだなーという点が多々。非常に勉強になりました。\nそれなりにフロントも見れるように、さらにJS勉強していきたい所存です。\n","href":"/post/javascript-enlightenment/","title":"『開眼! JavaScript』読んだ"},{"content":"","href":"/tags/%E8%AA%AD%E6%9B%B8/","title":"読書"},{"content":"","href":"/tags/spring/","title":"Spring"},{"content":"12/18に開催されたSpring Fest 2019に参加してきました。 その時聞いたものについてのレポートです。\n基調講演：From Spring Boot 2.2 to Spring Boot 2.3 スライド\nSpring Boot 2.2での目玉機能、2.3で追加される予定のもの、Spring Cloudについての紹介でした。 気になったものいくつか取り上げます。\nHealth Indicator Group ヘルスチェックのエンドポイントを複数、グループ別で設定できる機能。\nmanagement.endpoint.health.group.liveness.include=ping management.endpoint.health.group.readiness.include=db,redis ↑の設定の場合、 /actguator/health/livenessと/actuator/health/redinessが提供される。\nサンプルの設定どおり、KubernetesのLiveness/Readiness Probeと相性よさげ。\nImmutable Configuration Properties コンストラクタインジェクションでCongiurationPropertiesが設定可能に。 →Setter不要。\nまたKotlinだとdata classにも適用できるとか。\nGraalVM Javaだけどネイティブアプリ化させたりできるやつ。 昨年のSpring Festでは出たばっかりのころだったけど、順調にサポートが厚くなってきている感じ。\n2020年に出るSpring 5.3になると、諸々設定が楽になるとのこと。\nCloud Native Buildpacks ソースコードを解析してOCI標準イメージを作成するツール。\n(OCI標準イメージとは、Open Container Initiativeが定めた標準仕様に沿ったコンテナイメージのこと。 https://www.publickey1.jp/blog/17/open_container_initiativeoci_v10.html)\npackというCLI使って簡単に試せる。\nhttps://github.com/buildpacks/pack\n特にKubernetes向けの場合、kpackというのも提供されている。 https://github.com/pivotal/kpack\nSpring Boot爆速開発超絶技巧 スライド\nひたすらIntelliJのショートカット・機能を紹介していただくというセッション。 結構知らないショートカットもあって為になりました。\n使えそうと思ったのが、breakpointのオプション。 「この条件に一致したらbreak」とか「breakせずにprintだけ行う」とかできる、知らなかった。。\nLINE公式アカウントのチャットシステムにおけるSpringおよびWebFluxの活用事例 スライド\nSpring WebFluxを実際にプロダクトに適用した事例紹介。\nWebFluxを利用することで、各リクエストをノンブロッキングで処理することで、1つのイベントループスレッドで複数リクエストを捌けるようになる。そしてサーバー数が減少につながる。\n実際うまく稼働できているとのこと。このあたり理解が浅いと感じたので、実際に触ってみようと思います。\nNissanConnectの舞台裏で動くSpring Boot／Spring Cloud 〜Microserviceの実運用の事例〜 スライド\n日産車とスマホアプリなどとを連携するシステムの裏側紹介と、Springに関するTips紹介でした。\nTipsで引っかかりそうと思ったのが、pacheHttpClientのデフォルト接続数問題。\nデフォルトだと同一ドメインに対して同時リクエスト2つまでしかできないので、maxConnPerRouteを設定する必要があるとのこと。実際ぶち当たると苦戦しそうですね。。\nSpring Developer のための コンテナ入門 Google Cloudさんによる、コンテナ、Kubernetesについて入門的な内容でした。\nここで紹介されていた、Jibはかなり使えそうな印象。\nhttps://github.com/GoogleContainerTools/jib\nJavaアプリのコンテナイメージを、Dockerfileいらずで作ってくれる優れもの。 Mavenプラグインも用意されていて、mvnコマンドだけでdocker build, docker pushまでできるみたい。 CI/CDでも設定削減できたり相性よさそうな気がします。\nQuarkus による超音速な Spring アプリケーション開発 スライド\nRedHatさんによるQuarkusの紹介でした。\nQuarkusとは、Kubernetesなどのコンテナ環境に最適化されたJavaアプリを実現するフレームワークのこと。\nフレームワーク起動時に、設定ファイル解析、クラスパス・クラスのスキャン、リフレクションの準備などJava実行時に毎回行う、時間かかるやつを一度だけ行うようにして、起動時間短縮・メモリ使用量削減につなげている。\nまた、従来のJITコンパイラ向けでも、GraalVMでネイティブイメージ向けにも両方利用できて、両方ともそれなりに恩恵を受けられるとのこと。\nEfficient Web Apps with Spring Boot 2 その場でSpring MVC -\u0026gt; Spring WebFluxに置き換えるライブコーディングでした。\n非同期化することでUI表示が目に見えて速くなるのが面白かった。\nSpring with React for Enterprise Application スライド\n業務アプリについて、変化できるUI、変化に強いシステムを作り上げる手法について、タグバンガーズさんがやっていることの紹介でした。\n イベントストーミングというモデリング手法の利用。「何が起こったか」「なぜ起こったか」といったことを付箋に書き、それらの関係性をホワイトボードに書いていって、境界づけなど行ってモデリングしていく手法。シンプルでとっつきやすそうでした。 UIではCSS-in-JSを利用。CSSがどう継承しているかとか分からなくなる事態を防ぐ。JSにうまく組み込むことでコンポーネントごとに管理できるように。 BEでは、イベントストーミングで分離した対象それぞれ、Springのエコシステムどれ使うか？を考える。それぞれ境界間の関係性に最適なのを選んでいく。 テストも、付箋の「○○ならば××」というのをそのままテストにできる。 結合テストのモック化は、Spring Cloud Contract, Pactの組み合わせがおすすめとのこと。  実際業務アプリ開発に多く関わっているので、参考にしてみたい部分が多くありました。\n全体通しての感想 今回よく聞いたキーワードとしては\u0026quot;Reactive\u0026quot;と\u0026quot;Native Image\u0026quot;ですかね。 どちらもCloud Nativeの流れに沿うようJava, Springを発展させようという動きなのでしょうか。\nまた個人的には、昨年に比べて「これ業務に活かせそう」という観点ができて楽しかったです。また来年も来よう。あと月次でやってるようなイベントにも参加してみたい所存です。\n","href":"/post/spring-fest-2019/","title":"Spring Fest 2019 参加レポート"},{"content":"","href":"/tags/%E5%8B%89%E5%BC%B7%E4%BC%9A/","title":"勉強会"},{"content":"","href":"/tags/go/","title":"Go"},{"content":"Google PhotosのAPIつかって自動アップロードするバッチつくってみたくて調べたところ、 GCPサービスみたくサービスアカウント使う、ってことはできないみたいだった\nhttps://developers.google.com/photos/library/guides/authentication-authorization#service-accounts\nOAuth 2.0の認証フローをたどる必要があるみたい。\nとはいえバッチつくるとき、初回のみ認証→次からはrefresh tokenで再利用という流れになるんだろうけど 初回のみ認証の実装をケチりたかったので、refresh token取得まで簡単に取得できるツールみたいなの書いてみた。\nabekoh/get-google-tokens\n GCPサイドバー-\u0026gt;APIとサービス-\u0026gt;認証情報 より、認証情報を作成-\u0026gt;OAuthクライアントID を選択 用途に応じた種類を選ぶ。任意の名前をつける。JS生成元・リダイレクトURIは http://localhost:8080 を指定  認証情報一覧から、ダウンロードボタンを押す。client_secret_XXX.apps.googleusercontent.com..jsonのようなjsonファイルが手に入る。 token取得ツールインストール  go get github.com/abekoh/get-google-tokens 次を実行。例では、Google Photos APIにアップロードする権限のみ。  get-google-tokens -json client_secret_XXX.apps.googleusercontent.com.json -scope https://www.googleapis.com/auth/photoslibrary.appendonly photoのスコープはここ参照 https://developers.google.com/photos/library/guides/authentication-authorization\n実行するとURLが表示されるので、アクセス。そしてスコープを許可。「このアプリは確認されていません」と表示されても進める。 リダイレクトされてlocalhostに移った後、ターミナルのほうを確認。Access TokenとRefresh Tokenが表示されている。  仕組みとしては、リダイレクト時にURLパラメータにcode=と認証コードが入るので、 それをWebサーバで受け取って、チャンネル送信して、POSTリクエストでトークン取得するという流れ。\nGo久しぶり書きましたが、こんな感じでWebサーバー立ち上げ簡単にできる点、CLI化も楽な点がよいですね。\n参考  Google API OAuth2.0のアクセストークン\u0026amp;リフレッシュトークン取得手順 2017年2月版 - Qiita  ","href":"/post/get-google-token-with-go/","title":"Google API の OAuth 2.0トークン取得するツールつくった"},{"content":"","href":"/tags/google-photos/","title":"Google Photos"},{"content":"","href":"/tags/circleci/","title":"CircleCI"},{"content":"","href":"/tags/github-pages/","title":"Github Pages"},{"content":"","href":"/tags/google-domains/","title":"Google Domains"},{"content":"","href":"/tags/hugo/","title":"Hugo"},{"content":"このブログの構築メモ。 やっぱりブログもGitHubで管理できたらいいなーと探したら、この組み合わせで簡単にいい感じにできそうだったのでやってみた。\nHugoとは https://gohugo.io/\nGo製の静的サイト生成ツール。 とにかく簡単にブログがつくれる。ブログじゃなくてもポートフォリオサイトやOSSプロジェクトページなんかもいける。\nMarkdownでかけるのも嬉しい。非常にGitHubフレンドリーな感じ。\n個人的に惜しいと思う点は、超スタンダードな感じのテーマの多くがGPLなところ。 編集中のはPrivateにする場合ここが引っかかってしまうので、なくなくそれらを弾いてテーマ選びました。\nとりあえずこれを無編集で使ってます。\nhttps://github.com/zwbetz-gh/vanilla-bootstrap-hugo-theme\n→ これに変更しました https://github.com/achary/engimo\n構成 Github Pagesの機能をつかって公開するんですが、Hugoのソース自体はPrivateで管理。 abekoh.github.ioにはCircleCIがmaster pushするだけ。\nCircleCI選んだ理由は、とりあえず有名でモダンなやつ試したかったから。 最近だとGithub Actionsがよかったかな、と後から思ったけどまぁいいか。\nCircleCI設定 hugoのビルドは、Orbがあったのでそれを使う。 Orbはビルド手順のテンプレートみたいなの。\nhttps://circleci.com/orbs/registry/orb/circleci/hugo\nその後、Github Pagesへのpushは手動で設定。 このあたり参考にさせていただきました。\n CircleCIでgithub pagesに自動デプロイする CircleCIでHugoを実行してGitHub Pagesにデプロイ  引っかかったのが、ssh鍵設定してもcloneできない問題。 こちら参考に、StrictHostKeyChecking=noにすれば解決しました。\n最終的に.circleci/config.ymlはこんな感じ。 なれてきたらまた直していきたい。\nversion: 2.1 orbs: hugo: circleci/hugo@0.4.1 jobs: deploy: docker: - image: cibuilds/base steps: - add_ssh_keys: # CirlceCIのSSH Permissionsに設定したSSH Keyのfingerprintを設定 fingerprints: - \u0026#34;SO:ME:FIN:G:ER:PR:IN:T\u0026#34; # ビルドしたworkspaceをもってくる - attach_workspace: at: . - deploy: name: deploy to Github Pages command: | # ssh警告無視 echo \u0026#34;HostName github.com\u0026#34; \u0026gt;\u0026gt; ~/.ssh/config echo \u0026#34;StrictHostKeyChecking no\u0026#34; \u0026gt;\u0026gt; ~/.ssh/config DEPLOY_DIR=deploy # USER_EMAILはCircleCIのEnvironment Variablesで設定 git config --global user.email $USER_EMAIL git config --global user.name $CIRCLE_USERNAME git clone git@github.com:abekoh/abekoh.github.io.git $DEPLOY_DIR cd $DEPLOY_DIR rm -vrf ./* cp -v -R ../public/* ./ # ドメイン設定 echo \u0026#34;blog.abekoh.dev\u0026#34; \u0026gt; CNAME git add -f . git commit -m \u0026#34;Deploy #$CIRCLE_BUILD_NUM from CircleCI [ci skip]\u0026#34; git push origin master -f workflows: version: 2.1 main: jobs: - hugo/build: # TODO: HTMLチェックをonに html-proofer: false # masterマージ時のみデプロイ - deploy: requires: - hugo/build filters: branches: only: master ドメイン設定 ついでにドメインも取得してみたので設定。\nGoogle Domainsで、devドメインつくりました。 年間1200円、安いですね。\nこのようにCNAME設定して、\nabekoh/abekoh.github.ioのSettingsでドメイン設定するだけ。\nなお、CNAMEファイルがpush時に毎回消えてしまうような設定になっているので、.cricleci/config.ymlのpipelineのとおりCNAMEを毎回作成するようにしています。\n感想 やっぱりGitHub上で完結できるのよいですね。書きたいネタをIssueに登録、PR作って解決という流れで一人で運用ができて楽しい。\n","href":"/post/how-to-build-this-blog/","title":"Hugo, Github Pages, CircleCIつかってブログ構築"},{"content":"以前Qiitaに投稿した記事の紹介。\n記事: Slackでスニペットを共有するためのVimプラグインつくってみた\nGitHub: abekoh/snipslack.vim\nVimからSlackのスニペットに、お手軽にポストできるプラグインつくってみた記事です。\n2018年の会社の新卒有志Advent Calendarに参加して書きました。\nVimmerとしては一度はプラグインつくってみたい、そんな意欲で書きました。\nVim Scriptにしっかり向き合えて楽しかった。正規表現とか結構独特。業務などに役立つかはさておき。\n作ったものの、実は最近はあまり自分でも使っていない。。\n社内独自のスニペットサービスが使い勝手優秀で、結局それに頼っています。\n","href":"/post/qiita-snipslack-vim/","title":"[Qiita] Slackでスニペットを共有するためのVimプラグインつくってみた"},{"content":"","href":"/tags/neovim/","title":"Neovim"},{"content":"","href":"/tags/qiita/","title":"Qiita"},{"content":"","href":"/tags/slack/","title":"Slack"},{"content":"","href":"/tags/vim/","title":"Vim"},{"content":"","href":"/tags/diary/","title":"diary"},{"content":"","href":"/categories/diary/","title":"diary"},{"content":"技術ブログはじめました。\n黙々と勉強しつつもアウトプットの機会もなく、なんだかもったいないと思いはじめまして、 今度こそと続けていきたい所存です。\nこのブログはHugoっていう静的ページエンジンでつくってみました。\nすべてGithub上で解決するのは良いですね。\nCI連携などもまぁいい感じに設定できたので、そのこともおいおい記そうかと思います。\nどうぞよろしくお願いいたします。\n","href":"/post/start-blog/","title":"ブログはじめました"},{"content":"","href":"/","title":"abekoh's tech note"},{"content":"Profile 名前: abekoh\n福岡出身、東京在住。\n某Web系企業で、Web広告関係のエンジニアやってます。\nメインで扱う言語はJavaです。\n学生時代は画像系の機械学習とかやってました。\n特にGAN (Generative Adversarial Nets)に注力していました。\nTopics 業務であつかうもの:\nJava, Spring Boot, TypeScript, AngularJS, Kubernetes, Cloud Foundry, Kafka, Oracle Database, MySQL, IntelliJ IDEA\n興味あるもの:\nGo, Kotlin, DDD, Vim, GCP, 自作キーボード\nPrivacy Policy 当ブログでは、利用状況を把握するためにGoogle Analyticsを利用しております。Google AnalyticsはCookieを利用して利用者の情報を収集します。Google Analyticsにおいてデータが収集、処理される仕組みについては、こちらをご参照ください。\n","href":"/about/","title":"About"},{"content":"","href":"/search/","title":""},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/series/","title":"Series"}]
