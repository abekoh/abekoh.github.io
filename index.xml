<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>abekoh&#39;s tech note</title>
    <link>https://blog.abekoh.dev/</link>
    <description>Recent content on abekoh&#39;s tech note</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>© 2019 abekoh</copyright>
    <lastBuildDate>Sun, 08 Dec 2019 14:06:13 +0900</lastBuildDate>
    
	<atom:link href="https://blog.abekoh.dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GitHub Actions &#43; PlantUMLでドメインモデルの管理を楽にする</title>
      <link>https://blog.abekoh.dev/post/plantuml-action/</link>
      <pubDate>Mon, 11 Jan 2021 22:30:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/plantuml-action/</guid>
      <description>ドメインモデルの図を複数人、エンジニア・ドメインエキスパート間で共有するにあたって、 やり方はいろいろ考えられますが、
 差分がわかりやすい バージョン管理ができる  という点からやはりGitで管理できると嬉しいと思います。
Gitで管理しやすいフォーマットとして、DSLから図を自動生成してくれるPlantUMLが使いやすく定番です。 ドメインモデルについては下図のようにオブジェクト図で書けるとよいかと思います。
(『実践ドメイン駆動設計』 P.356, 図10-7をもとに作成)
このPlantUMLによるドメインモデルの管理をGitHubのPR上で効率行えるようにするための、Github Actionsのテンプレを開発しMarketplaceに公開しました。
Generate and Commit PlantUML Diagrams · Actions · GitHub Marketplace
使い方などはREADMEを参考に。使い勝手は以下のサンプルPRを見ていただければわかりやすいと思います。
Example by abekoh · Pull Request #33 · abekoh/commit-plantuml-action
.pumlファイルに差分が生じたとき、同じところに.pngとして画像が生成され、コミットされます。
さらにenableReviewCommentを有効にすれば、生成された図のリンクとプレビューがコメントに投稿されます。 Beforeを展開して古い図との差分も確認可能です。
毎回リンクをたどってレビューを行う必要がなく、使い勝手よく扱えると思います。
注意点としては、PlantUMLが依存しているgraphvizの影響でライセンスがGPLとなっている点です…
このあたりのPlantUMLの別実装を使ってより緩いライセンス使えないか、模索していきたいところ。</description>
    </item>
    
    <item>
      <title>[Qiita] トランザクションスクリプトなシステムをもとに、Cleanなシステムを構築する</title>
      <link>https://blog.abekoh.dev/post/advent-calendar-2020-ddd/</link>
      <pubDate>Mon, 21 Dec 2020 20:39:03 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/advent-calendar-2020-ddd/</guid>
      <description>ドメイン駆動設計 Advent Calendar 2020 に参加しました。
トランザクションスクリプトなシステムをもとに、Cleanなシステムを構築する - Qiita</description>
    </item>
    
    <item>
      <title>「ドメイン駆動設計」関連書籍の紹介・オススメの読み順</title>
      <link>https://blog.abekoh.dev/post/ddd-books/</link>
      <pubDate>Sun, 18 Oct 2020 02:58:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/ddd-books/</guid>
      <description>社内LT会の好評だったところ一部抜粋。
DDD関連の本を読み漁って、それぞれの感想一言メモと、どの順で読んだらいいか考えてみたやつを紹介。
戦略的設計と戦術的設計 この記事でDDDの内容にはちゃんと触れないけどこの点だけ説明。
DDDの考え方、パターンは数あれど、それらは 「戦略的設計」と「戦術的設計」に分類することができる。 関連書籍はこのどちらかに偏っていることが多い。
戦略的設計 &amp;hellip; チームで使うパターン。よりマネジメント向き。
戦術的設計 &amp;hellip; テクニカルなパターン。具体的なクラス設計とか。
お硬めの2冊 エリック・エヴァンスのドメイン駆動設計 原著: 2003年、訳書: 2011年発行
Evans本。原著。古い箇所もあるけどすべてが詰まっている。
レビューなどで「抽象的でわかりにくい」ってコメントが多くて身構えていたけど、思ってたより具体的な例も出てきて楽しめた。 (ある程度DDDに関する知識蓄えてからってのが大きいけど。)
実践ドメイン駆動設計 原著: 2013年、訳書: 2015年発行
IDDD本。Evans本からより実践方面に落とし込んだもの。戦術的設計が多め。
Evans本にはない概念も登場する。(ドメインイベントあたり)
「Evans本よりこの本から読んだほうがとっつきやすい」ってコメントがいくつかあったのでここから入ったけど、Evans本の内容が前提として扱われているので割と辛い。
やわらかめ3冊 わかる！ドメイン駆動設計 ～もちこちゃんの大冒険～ 2016年発行
同人誌。ほぼ戦略的設計のみ扱う。
Evans本、IDDD本を引用しつつゆるふわに解説されててとっつきやすい。
ドメイン駆動設計入門 ボトムアップでわかる! ドメイン駆動設計の基本 2020年発行
今年出たばかりの本。戦術的設計中心。
DDDで使われるパターンをいきなりコードで説明する感じで、具体的でイメージがすぐに掴める。
初学者の「DDD難しそう辛そう」というイメージを解きほぐすような解説がとてもよかった。 C#だけどJava知ってたら違和感ない内容だった。
「実践ドメイン駆動設計」から学ぶDDDの実装入門 2019年発行
IDDD本の副読本。もともとCodeZineの連載物で、Amazonでオンデマンドで印刷できるやつ。 構成はIDDD本と全く同じで、一緒に読み進めるとよさそう。
読み順について 読みやすさ、扱う内容でマッピングして、個人的おすすめな読み順をつけるとこんな感じ。
ドメイン駆動設計入門がとにかくわかりやすく、「DDD頑張れそう」って勇気もらえるからここからがオススメ。戦術的設計に偏ってるので、その後はもちこちゃんで戦略的設計を掴む。
そこからEvans本→IDDD本(副読本も一緒がいいかも？)という流れで、頭悩ませながら読むのがよいんじゃないかなって思う。
まとめ これで僕は完全に理解しました。エンジニア的な意味でです。
業務などでの実践面はまだまだなのでﾁｮｯﾄﾃﾞｷﾙようになりたいです。</description>
    </item>
    
    <item>
      <title>あつ森のアイテムカタログサービスつくった、けれど公開はやめた話</title>
      <link>https://blog.abekoh.dev/post/atsumori-app/</link>
      <pubDate>Sun, 28 Jun 2020 15:08:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/atsumori-app/</guid>
      <description>3月ごろからあつ森にハマり、それから自粛期間に入りまして。 お家時間増えたし何か個人開発したい！と思い、思いついたのが「あつ森のアイテムをWeb上でらくらくに検索したりできるサービス」でした。
1ヶ月くらいかけてコツコツと作りあげたものの、公開しよう！ってタイミングで結局諦めることにしました。 実際どんなもの作ったか、公開やめた理由、どんな学びがあったのか、成仏のためにも記事にしようと思います。
どんなサービス？ あつ森に出てくる家具、服などのアイテムを簡単に検索でき、そのバリエーションや入手方法などをチェックすることができます。
デモはこちら。 左側のメニューから、キーワード検索でアイテムを探すことができます。しぼりこみ検索では「ジョニーからもらえる家具」といった条件で検索ができます。 またマイリスト機能もつけていまして、ログインしていたら欲しい物を管理、公開することが可能になってます。
レスポンシブなので、スマホにも対応しています。 なぜ公開をやめたか やっぱり著作権的にアウトだと判断し、お蔵入りにすることにしました。
多くのあつ森攻略サイトで家具一覧ページが存在していたり、某ポケモン攻略サイトが公式からOKもらっていたりと前例があるので、 1ファンサイトとして公開してもいいかなと思ってましたが…
 公式の画像バリバリ使ってしまってる点は、二次利用として「常識の範囲」を超えている点 「ゲーム買わなくてもこれ見たら満足してしまう」という不利益を与えてしまう可能性がある点  など、不安が残る点がクリアにできず。 個人的には任天堂の大ファンなので、変に迷惑かけるのも嫌でして。あくまで個人範囲で楽しむものまでに留めることにしました。
学びなど 諦めたものの、Webアプリをしっかり個人開発したのが初だったので多くの学びがありました。 その学びを備忘録的にメモしておこうと思います。
今回つかった技術まわりは次の通りです。
 フロント  Nuxt.js  SPAモード not TypeScript   Vuetify   データまわり  Python (アイテムデータの収集、整形、DB登録など)   インフラ  Firebase  Authentication Cloud Firestore Hosting (Functions)   Algolia (全文検索エンジン)    以下、感想など
Vuetifyがつよい Vue Material Design Component Framework — Vuetify.js
デザインフレームワークとして今回Vuetifyを選んだのですが、強力すぎてビビりました。 CSSを全く書くことなく、HTMLテンプレ書くだけでいい感じの見た目になります。</description>
    </item>
    
    <item>
      <title>Google Maps APIをSpringで使ってみる</title>
      <link>https://blog.abekoh.dev/post/google-maps-api-with-spring/</link>
      <pubDate>Sun, 05 Apr 2020 23:43:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/google-maps-api-with-spring/</guid>
      <description>Google Mapsの場所情報が使えるPlaces APIを使ったアプリケーションを作ってみたく、実装ためしたメモ。
Google Maps API 単にGoogle Maps APIといってもその用途によって、ドキュメントや料金体系が別れている。
ドキュメント一覧はここで、目的に合ったAPIを選ぶ。 https://developers.google.com/maps/documentation
料金についてはここ。記事を書いている時点で、モバイル向けマップ表示は無料だったり、ある道路の制限速度を取得するAPIは1000件あたり$20と細かい。1ヶ月$200までは無料で使える。
https://cloud.google.com/maps-platform/pricing/
今回はPlaces API for Webを使ってみる。指定した場所周辺の飲食店一覧や、その飲食店のレビュー情報なんかが取得できる。
Places APIの中でも、場所を探す、場所の詳細情報を取得する、その周辺の写真を取得する、で料金体系が違うので注意。
APIの有効化 ここに書いてあるとおり順にやってく。
https://developers.google.com/places/web-service/get-api-key
手順通り進めたら、API Keyが発行できる。このキーをクエリパラメータに含めるなどして扱う。
発行できたらcurlつかってテスト。
curl &amp;#34;https://maps.googleapis.com/maps/api/place/nearbysearch/json?key={replace your API Key}&amp;amp;location=35.6812362,139.7649361&amp;amp;radius=100&amp;amp;language=ja&amp;amp;keyword=ramen&amp;#34; 上記はNearby Searchを使って、東京駅周辺半径100mで、キーワード&amp;quot;ramen&amp;quot;でお店を探すサンプル。
ドキュメントに書かれているとおり、API Keyには利用元の制限をかけるべき。IPアドレスやリファラなどで設定可能。
実装 Java向け公式のクライアントがあったのでそれ利用。
https://github.com/googlemaps/google-maps-services-java
依存を追加。
// build.gradle.kts dependencies { implementation(&amp;#34;com.google.maps:google-maps-services:0.11.0&amp;#34;) } 使い方は次のような感じ。
// https://github.com/googlemaps/google-maps-services-java/blob/master/README.md より GeoApiContext context = new GeoApiContext.Builder() .apiKey(&amp;#34;AIza...&amp;#34;) .build(); GeocodingResult[] results = GeocodingApi.geocode(context, &amp;#34;1600 Amphitheatre Parkway Mountain View, CA 94043&amp;#34;).await(); Gson gson = new GsonBuilder().</description>
    </item>
    
    <item>
      <title>fish,tmux,neovim,ghq,pecoで開発スペース構築を快適にする</title>
      <link>https://blog.abekoh.dev/post/prj-command/</link>
      <pubDate>Sat, 14 Mar 2020 01:43:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/prj-command/</guid>
      <description>ちょっとしたコード編集とかだったらターミナル上だけで完結させるのが好きでして。 効率よくプロジェクト選択、そのまま編集したりしやすくなる prj というコマンドを自作しています。 また、これに加えて使いやすいように他にも設定盛り込んでます。
なんだかんだ1年以上運用していて、満足しているのでアウトプットしておきます。
環境 次のような環境が必要です
 Neovim  neovim-remote   tmux fish peco  Neovim,tmuxは必須ですが、fish,pecoはzsh,fzfに書き換えても良いと思います。 インストール方法はそれぞれリンク先を参照してください。
デモ わかりにくいかもですが、次のような特徴をみせてます。
 prjで、ghqにより管理されたgitリポジトリをpecoをつかって選択 リポジトリを選択するとそのプロジェクト用のtmuxセッションが開かれ、カレントディレクトリがそのリポジトリ配下になる tmuxセッション内で、Neovimは1タブでしか開けない tmuxセッション内でもう一度prjを実行すると、別のプロジェクトも開ける  次の項でその実現方法を解説します。
解説 prjコマンド ghqとpecoの連携についてはこちらの記事の考えをそのまま使っています。
ghq, peco, hubで快適Gitライフを手に入れよう！ - Qiita
この組み合わせによって、レポジトリ管理・選択が劇的に楽になります。 さらに小細工を入れてtmuxセッションを開くようにしました。
prjコマンドはfish scriptで書いています。こんな感じ
# prj.fish function prj -d &amp;#34;start project&amp;#34; # 引数が設定されていれば、それをpecoにわたす  if test (count $argv) -gt 0 set prjflag --query &amp;#34;$argv&amp;#34; end set PRJ_PATH (ghq root)/(ghq list | peco $prjflag) # プロジェクトが選択されなければ終了  if test -z $PRJ_PATH return end # プロジェクト名は 所有者/リポジトリ名 の形式。その名前に`.</description>
    </item>
    
    <item>
      <title>Cloud Storage経由でCloud Buildを動かしてデプロイする</title>
      <link>https://blog.abekoh.dev/post/gcp-deploy-functions-from-storage/</link>
      <pubDate>Sun, 08 Mar 2020 23:30:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/gcp-deploy-functions-from-storage/</guid>
      <description>GCPサービスの1つ、Cloud BuildはいわゆるCI/CDツールです。 GithubなどGitレポジトリに紐づけてトリガーさせて使うのが普通だと思います。UIから設定できるトリガーとしても現状、リポジトリ経由しか選択できません。
しかし、業務のある都合でCloud Storage経由でデプロイしたいことがありまして。 やり方を模索してみてうまくいったので、メモっておきます。
ソース こちらに置いてます。
abekoh/gcp-deploy-from-storage
全体像 今回はhello-funcというファンクションを、tar.gzに圧縮したソースからCloud Functionsにデプロイするというシナリオとします。 デプロイ対象はApp Engineとか、別のサービスでもいけるはず。
デプロイ対象 シンプルにHTTPリクエストおくるとHelloが返ってくるFunctionです。Node.jsで書きます。
// index.js exports.hello = (req, res) =&amp;gt; { res.send(&amp;#39;Hello, world!&amp;#39;); } これと、npm initで生成したpackage.jsonを含んだhello-func.tar.gzを作っておきます。
tar zcvf hello-func.tar.gz index.js package.json ビルドファンクション実装 メインとなるビルド用ファンクションです。
Storageのイベントをトリガーとして発火させ、Cloud BuildのAPIを叩いてビルド、デプロイを実行します。
Node.js用のGoogle APIクライアントとして、普通はこちらを使いますが
googlespis/google-api-nodejs-client
READMEにも書かれている通り、GCP上で利用する場合は下記のライブラリのほうが使い勝手いいみたいです。
googleapis/google-cloud-node
Cloud Buildの依存を追加します。
npm init npm i -S @google-cloud/cloudbuild ビルド用Functionsの実装はこちら。
// index.js &amp;#39;use strict&amp;#39;; const {CloudBuildClient} = require(&amp;#39;@google-cloud/cloudbuild&amp;#39;); exports.build = async file =&amp;gt; { // file.metageneration: メタ情報が更新されるとインクリメントされる値  // ファイル自体が更新されるときは&amp;#39;1&amp;#39;となる  if (file.</description>
    </item>
    
    <item>
      <title>『開眼! JavaScript』読んだ</title>
      <link>https://blog.abekoh.dev/post/javascript-enlightenment/</link>
      <pubDate>Sun, 23 Feb 2020 18:20:11 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/javascript-enlightenment/</guid>
      <description>Oreillyから出てる『開眼！ JavaScript ――言語仕様から学ぶJavaScriptの本質』の読書メモです。
https://www.oreilly.co.jp/books/9784873116211/
仕事でもWebフロントアプリを触ることがあるものの、既存のコードを雰囲気で改修する程度で、今ひとつJSの挙動など理解できていなかったのでその辺りが知りたく。 ちょうどこの本が「JavaScript特有の癖、落とし穴」にフォーカスを当てていて、大変参考になりました。
以下、刺さったところの個人的メモ。
JSは基本なんでもオブジェクト、プリミティブでもオブジェクトのように扱える number, string, boolean, null, undefinedはプリミティブ、他はすべてオブジェクト扱い。 Array、Functionも結局Objectを着色したようなイメージ。
プリミティブであっても、それに対応するラッパーオブジェクト(numberならNumber)のプロパティ、メソッドが呼び出せる。呼び出したとき、そのときだけオブジェクトを生成→破棄という流れになる。
&amp;#39;hoge&amp;#39;.length // -&amp;gt; 4 JSのオブジェクトはミュータブル、基本なんでも挙動変えられる Arrayなどネイティブコンストラクタを持つオブジェクトであっても、windowなどグローバルオブジェクトであっても、そのプロパティ・メソッドは書き換え可能。 window.alert()でも書き換えて機能停止させることも可能。varつけずfoo = &#39;bar&#39;とやればグローバルオブジェクトのプロパティをいじったことになる。
もちろん、可能なだけで破壊的な変更は推奨されない。
thisはそれを呼び出すタイミングで指すものが決まる var foo = &amp;#39;foo&amp;#39;; var myObject = { foo: &amp;#39;I am myObject.foo&amp;#39; }; var sayFoo = function() { console.log(this[&amp;#39;foo&amp;#39;]); }; // myObjectのsayFooメソッドにsayFoo()関数を与える myObject.sayFoo = sayFoo; myObject.sayFoo(); // myObject.sayFoo()内でのthisはmyObjectなので&amp;#39;I am myObject.foo&amp;#39;を出力 sayFoo(); // sayFoo()内でのthisはグローバルオブジェクトなので&amp;#39;foo&amp;#39;を出力 (P.87より引用)
定義時の&amp;rsquo;foo&#39;が常に出ると予想されるかもだが、実際は実行時のコンテキストに依存する。
無名関数の即時実行 (function(){ console.log(&amp;#39;hoge&amp;#39;); })() functionの中身を即実行する書き方。 何度かこんなコードみたことあったのに、意味理解できていなかった。。
関数の巻き上げ function後ろのほうで定義、前のほうで実行でも問題なし。
foo(); // -&amp;gt; hoge function foo() { console.</description>
    </item>
    
    <item>
      <title>Spring Fest 2019 参加レポート</title>
      <link>https://blog.abekoh.dev/post/spring-fest-2019/</link>
      <pubDate>Mon, 30 Dec 2019 02:05:02 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/spring-fest-2019/</guid>
      <description>12/18に開催されたSpring Fest 2019に参加してきました。 その時聞いたものについてのレポートです。
基調講演：From Spring Boot 2.2 to Spring Boot 2.3 スライド
Spring Boot 2.2での目玉機能、2.3で追加される予定のもの、Spring Cloudについての紹介でした。 気になったものいくつか取り上げます。
Health Indicator Group ヘルスチェックのエンドポイントを複数、グループ別で設定できる機能。
management.endpoint.health.group.liveness.include=ping management.endpoint.health.group.readiness.include=db,redis ↑の設定の場合、 /actguator/health/livenessと/actuator/health/redinessが提供される。
サンプルの設定どおり、KubernetesのLiveness/Readiness Probeと相性よさげ。
Immutable Configuration Properties コンストラクタインジェクションでCongiurationPropertiesが設定可能に。 →Setter不要。
またKotlinだとdata classにも適用できるとか。
GraalVM Javaだけどネイティブアプリ化させたりできるやつ。 昨年のSpring Festでは出たばっかりのころだったけど、順調にサポートが厚くなってきている感じ。
2020年に出るSpring 5.3になると、諸々設定が楽になるとのこと。
Cloud Native Buildpacks ソースコードを解析してOCI標準イメージを作成するツール。
(OCI標準イメージとは、Open Container Initiativeが定めた標準仕様に沿ったコンテナイメージのこと。 https://www.publickey1.jp/blog/17/open_container_initiativeoci_v10.html)
packというCLI使って簡単に試せる。
https://github.com/buildpacks/pack
特にKubernetes向けの場合、kpackというのも提供されている。 https://github.com/pivotal/kpack
Spring Boot爆速開発超絶技巧 スライド
ひたすらIntelliJのショートカット・機能を紹介していただくというセッション。 結構知らないショートカットもあって為になりました。
使えそうと思ったのが、breakpointのオプション。 「この条件に一致したらbreak」とか「breakせずにprintだけ行う」とかできる、知らなかった。。
LINE公式アカウントのチャットシステムにおけるSpringおよびWebFluxの活用事例 スライド
Spring WebFluxを実際にプロダクトに適用した事例紹介。
WebFluxを利用することで、各リクエストをノンブロッキングで処理することで、1つのイベントループスレッドで複数リクエストを捌けるようになる。そしてサーバー数が減少につながる。
実際うまく稼働できているとのこと。このあたり理解が浅いと感じたので、実際に触ってみようと思います。
NissanConnectの舞台裏で動くSpring Boot／Spring Cloud 〜Microserviceの実運用の事例〜 スライド</description>
    </item>
    
    <item>
      <title>Google API の OAuth 2.0トークン取得するツールつくった</title>
      <link>https://blog.abekoh.dev/post/get-google-token-with-go/</link>
      <pubDate>Sat, 21 Dec 2019 13:52:48 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/get-google-token-with-go/</guid>
      <description>Google PhotosのAPIつかって自動アップロードするバッチつくってみたくて調べたところ、 GCPサービスみたくサービスアカウント使う、ってことはできないみたいだった
https://developers.google.com/photos/library/guides/authentication-authorization#service-accounts
OAuth 2.0の認証フローをたどる必要があるみたい。
とはいえバッチつくるとき、初回のみ認証→次からはrefresh tokenで再利用という流れになるんだろうけど 初回のみ認証の実装をケチりたかったので、refresh token取得まで簡単に取得できるツールみたいなの書いてみた。
abekoh/get-google-tokens
 GCPサイドバー-&amp;gt;APIとサービス-&amp;gt;認証情報 より、認証情報を作成-&amp;gt;OAuthクライアントID を選択 用途に応じた種類を選ぶ。任意の名前をつける。JS生成元・リダイレクトURIは http://localhost:8080 を指定  認証情報一覧から、ダウンロードボタンを押す。client_secret_XXX.apps.googleusercontent.com..jsonのようなjsonファイルが手に入る。 token取得ツールインストール  go get github.com/abekoh/get-google-tokens 次を実行。例では、Google Photos APIにアップロードする権限のみ。  get-google-tokens -json client_secret_XXX.apps.googleusercontent.com.json -scope https://www.googleapis.com/auth/photoslibrary.appendonly photoのスコープはここ参照 https://developers.google.com/photos/library/guides/authentication-authorization
実行するとURLが表示されるので、アクセス。そしてスコープを許可。「このアプリは確認されていません」と表示されても進める。 リダイレクトされてlocalhostに移った後、ターミナルのほうを確認。Access TokenとRefresh Tokenが表示されている。  仕組みとしては、リダイレクト時にURLパラメータにcode=と認証コードが入るので、 それをWebサーバで受け取って、チャンネル送信して、POSTリクエストでトークン取得するという流れ。
Go久しぶり書きましたが、こんな感じでWebサーバー立ち上げ簡単にできる点、CLI化も楽な点がよいですね。
参考  Google API OAuth2.0のアクセストークン&amp;amp;リフレッシュトークン取得手順 2017年2月版 - Qiita  </description>
    </item>
    
    <item>
      <title>Hugo, Github Pages, CircleCIつかってブログ構築</title>
      <link>https://blog.abekoh.dev/post/how-to-build-this-blog/</link>
      <pubDate>Sat, 14 Dec 2019 13:40:05 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/how-to-build-this-blog/</guid>
      <description>このブログの構築メモ。 やっぱりブログもGitHubで管理できたらいいなーと探したら、この組み合わせで簡単にいい感じにできそうだったのでやってみた。
Hugoとは https://gohugo.io/
Go製の静的サイト生成ツール。 とにかく簡単にブログがつくれる。ブログじゃなくてもポートフォリオサイトやOSSプロジェクトページなんかもいける。
Markdownでかけるのも嬉しい。非常にGitHubフレンドリーな感じ。
個人的に惜しいと思う点は、超スタンダードな感じのテーマの多くがGPLなところ。 編集中のはPrivateにする場合ここが引っかかってしまうので、なくなくそれらを弾いてテーマ選びました。
とりあえずこれを無編集で使ってます。
https://github.com/zwbetz-gh/vanilla-bootstrap-hugo-theme
→ これに変更しました https://github.com/achary/engimo
構成 Github Pagesの機能をつかって公開するんですが、Hugoのソース自体はPrivateで管理。 abekoh.github.ioにはCircleCIがmaster pushするだけ。
CircleCI選んだ理由は、とりあえず有名でモダンなやつ試したかったから。 最近だとGithub Actionsがよかったかな、と後から思ったけどまぁいいか。
CircleCI設定 hugoのビルドは、Orbがあったのでそれを使う。 Orbはビルド手順のテンプレートみたいなの。
https://circleci.com/orbs/registry/orb/circleci/hugo
その後、Github Pagesへのpushは手動で設定。 このあたり参考にさせていただきました。
 CircleCIでgithub pagesに自動デプロイする CircleCIでHugoを実行してGitHub Pagesにデプロイ  引っかかったのが、ssh鍵設定してもcloneできない問題。 こちら参考に、StrictHostKeyChecking=noにすれば解決しました。
最終的に.circleci/config.ymlはこんな感じ。 なれてきたらまた直していきたい。
version: 2.1 orbs: hugo: circleci/hugo@0.4.1 jobs: deploy: docker: - image: cibuilds/base steps: - add_ssh_keys: # CirlceCIのSSH Permissionsに設定したSSH Keyのfingerprintを設定 fingerprints: - &amp;#34;SO:ME:FIN:G:ER:PR:IN:T&amp;#34; # ビルドしたworkspaceをもってくる - attach_workspace: at: . - deploy: name: deploy to Github Pages command: | # ssh警告無視 echo &amp;#34;HostName github.</description>
    </item>
    
    <item>
      <title>[Qiita] Slackでスニペットを共有するためのVimプラグインつくってみた</title>
      <link>https://blog.abekoh.dev/post/qiita-snipslack-vim/</link>
      <pubDate>Wed, 11 Dec 2019 23:52:09 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/qiita-snipslack-vim/</guid>
      <description>以前Qiitaに投稿した記事の紹介。
記事: Slackでスニペットを共有するためのVimプラグインつくってみた
GitHub: abekoh/snipslack.vim
VimからSlackのスニペットに、お手軽にポストできるプラグインつくってみた記事です。
2018年の会社の新卒有志Advent Calendarに参加して書きました。
Vimmerとしては一度はプラグインつくってみたい、そんな意欲で書きました。
Vim Scriptにしっかり向き合えて楽しかった。正規表現とか結構独特。業務などに役立つかはさておき。
作ったものの、実は最近はあまり自分でも使っていない。。
社内独自のスニペットサービスが使い勝手優秀で、結局それに頼っています。</description>
    </item>
    
    <item>
      <title>ブログはじめました</title>
      <link>https://blog.abekoh.dev/post/start-blog/</link>
      <pubDate>Wed, 11 Dec 2019 00:48:56 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/start-blog/</guid>
      <description>技術ブログはじめました。
黙々と勉強しつつもアウトプットの機会もなく、なんだかもったいないと思いはじめまして、 今度こそと続けていきたい所存です。
このブログはHugoっていう静的ページエンジンでつくってみました。
すべてGithub上で解決するのは良いですね。
CI連携などもまぁいい感じに設定できたので、そのこともおいおい記そうかと思います。
どうぞよろしくお願いいたします。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://blog.abekoh.dev/about/</link>
      <pubDate>Sun, 08 Dec 2019 14:06:13 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/about/</guid>
      <description>Profile 名前: abekoh
福岡出身、東京在住。
某Web系企業で、Web広告関係のエンジニアやってます。
メインで扱う言語はJavaです。
学生時代は画像系の機械学習とかやってました。
特にGAN (Generative Adversarial Nets)に注力していました。
Topics 業務であつかうもの:
Java, Spring Boot, TypeScript, AngularJS, Kubernetes, Cloud Foundry, Kafka, Oracle Database, MySQL, IntelliJ IDEA
興味あるもの:
Go, Kotlin, DDD, Vim, GCP, 自作キーボード
Privacy Policy 当ブログでは、利用状況を把握するためにGoogle Analyticsを利用しております。Google AnalyticsはCookieを利用して利用者の情報を収集します。Google Analyticsにおいてデータが収集、処理される仕組みについては、こちらをご参照ください。</description>
    </item>
    
  </channel>
</rss>