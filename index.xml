<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>abekoh&#39;s tech note</title>
    <link>https://blog.abekoh.dev/</link>
    <description>Recent content on abekoh&#39;s tech note</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>© abekoh</copyright>
    <lastBuildDate>Sun, 08 Dec 2019 14:06:13 +0900</lastBuildDate>
    
	<atom:link href="https://blog.abekoh.dev/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>fish,tmux,neovim,ghq,pecoで開発スペース構築を快適にする</title>
      <link>https://blog.abekoh.dev/post/prj-command/</link>
      <pubDate>Sat, 14 Mar 2020 01:43:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/prj-command/</guid>
      <description>ちょっとしたコード編集とかだったらターミナル上だけで完結させるのが好きでして。 効率よくプロジェクト選択、そのまま編集したりしやすくなる prj というコマンドを自作しています。 また、これに加えて使いやすいように他にも設定盛り込んでます。
なんだかんだ1年以上運用していて、満足しているのでアウトプットしておきます。
環境 次のような環境が必要です
 Neovim  neovim-remote   tmux fish peco  Neovim,tmuxは必須ですが、fish,pecoはzsh,fzfに書き換えても良いと思います。 インストール方法はそれぞれリンク先を参照してください。
デモ わかりにくいかもですが、次のような特徴をみせてます。
 prjで、ghqにより管理されたgitリポジトリをpecoをつかって選択 リポジトリを選択するとそのプロジェクト用のtmuxセッションが開かれ、カレントディレクトリがそのリポジトリ配下になる tmuxセッション内で、Neovimは1タブでしか開けない tmuxセッション内でもう一度prjを実行すると、別のプロジェクトも開ける  次の項でその実現方法を解説します。
解説 prjコマンド ghqとpecoの連携についてはこちらの記事の考えをそのまま使っています。
ghq, peco, hubで快適Gitライフを手に入れよう！ - Qiita
この組み合わせによって、レポジトリ管理・選択が劇的に楽になります。 さらに小細工を入れてtmuxセッションを開くようにしました。
prjコマンドはfish scriptで書いています。こんな感じ
# prj.fish function prj -d &amp;#34;start project&amp;#34; # 引数が設定されていれば、それをpecoにわたす  if test (count $argv) -gt 0 set prjflag --query &amp;#34;$argv&amp;#34; end set PRJ_PATH (ghq root)/(ghq list | peco $prjflag) # プロジェクトが選択されなければ終了  if test -z $PRJ_PATH return end # プロジェクト名は 所有者/リポジトリ名 の形式。その名前に`.</description>
    </item>
    
    <item>
      <title>Cloud Storage経由でCloud Buildを動かしてデプロイする</title>
      <link>https://blog.abekoh.dev/post/gcp-deploy-functions-from-storage/</link>
      <pubDate>Sun, 08 Mar 2020 23:30:00 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/gcp-deploy-functions-from-storage/</guid>
      <description>GCPサービスの1つ、Cloud BuildはいわゆるCI/CDツールです。 GithubなどGitレポジトリに紐づけてトリガーさせて使うのが普通だと思います。UIから設定できるトリガーとしても現状、リポジトリ経由しか選択できません。
しかし、業務のある都合でCloud Storage経由でデプロイしたいことがありまして。 やり方を模索してみてうまくいったので、メモっておきます。
ソース こちらに置いてます。
abekoh/gcp-deploy-from-storage
全体像 今回はhello-funcというファンクションを、tar.gzに圧縮したソースからCloud Functionsにデプロイするというシナリオとします。 デプロイ対象はApp Engineとか、別のサービスでもいけるはず。
デプロイ対象 シンプルにHTTPリクエストおくるとHelloが返ってくるFunctionです。Node.jsで書きます。
// index.js exports.hello = (req, res) =&amp;gt; { res.send(&amp;#39;Hello, world!&amp;#39;); } これと、npm initで生成したpackage.jsonを含んだhello-func.tar.gzを作っておきます。
tar zcvf hello-func.tar.gz index.js package.json ビルドファンクション実装 メインとなるビルド用ファンクションです。
Storageのイベントをトリガーとして発火させ、Cloud BuildのAPIを叩いてビルド、デプロイを実行します。
Node.js用のGoogle APIクライアントとして、普通はこちらを使いますが
googlespis/google-api-nodejs-client
READMEにも書かれている通り、GCP上で利用する場合は下記のライブラリのほうが使い勝手いいみたいです。
googleapis/google-cloud-node
Cloud Buildの依存を追加します。
npm init npm i -S @google-cloud/cloudbuild ビルド用Functionsの実装はこちら。
// index.js &amp;#39;use strict&amp;#39;; const {CloudBuildClient} = require(&amp;#39;@google-cloud/cloudbuild&amp;#39;); exports.build = async file =&amp;gt; { // file.metageneration: メタ情報が更新されるとインクリメントされる値  // ファイル自体が更新されるときは&amp;#39;1&amp;#39;となる  if (file.</description>
    </item>
    
    <item>
      <title>『開眼! JavaScript』読んだ</title>
      <link>https://blog.abekoh.dev/post/javascript-enlightenment/</link>
      <pubDate>Sun, 23 Feb 2020 18:20:11 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/javascript-enlightenment/</guid>
      <description>Oreillyから出てる『開眼！ JavaScript ――言語仕様から学ぶJavaScriptの本質』の読書メモです。
https://www.oreilly.co.jp/books/9784873116211/
仕事でもWebフロントアプリを触ることがあるものの、既存のコードを雰囲気で改修する程度で、今ひとつJSの挙動など理解できていなかったのでその辺りが知りたく。 ちょうどこの本が「JavaScript特有の癖、落とし穴」にフォーカスを当てていて、大変参考になりました。
以下、刺さったところの個人的メモ。
JSは基本なんでもオブジェクト、プリミティブでもオブジェクトのように扱える number, string, boolean, null, undefinedはプリミティブ、他はすべてオブジェクト扱い。 Array、Functionも結局Objectを着色したようなイメージ。
プリミティブであっても、それに対応するラッパーオブジェクト(numberならNumber)のプロパティ、メソッドが呼び出せる。呼び出したとき、そのときだけオブジェクトを生成→破棄という流れになる。
&amp;#39;hoge&amp;#39;.length // -&amp;gt; 4 JSのオブジェクトはミュータブル、基本なんでも挙動変えられる Arrayなどネイティブコンストラクタを持つオブジェクトであっても、windowなどグローバルオブジェクトであっても、そのプロパティ・メソッドは書き換え可能。 window.alert()でも書き換えて機能停止させることも可能。varつけずfoo = &#39;bar&#39;とやればグローバルオブジェクトのプロパティをいじったことになる。
もちろん、可能なだけで破壊的な変更は推奨されない。
thisはそれを呼び出すタイミングで指すものが決まる var foo = &amp;#39;foo&amp;#39;; var myObject = { foo: &amp;#39;I am myObject.foo&amp;#39; }; var sayFoo = function() { console.log(this[&amp;#39;foo&amp;#39;]); }; // myObjectのsayFooメソッドにsayFoo()関数を与える myObject.sayFoo = sayFoo; myObject.sayFoo(); // myObject.sayFoo()内でのthisはmyObjectなので&amp;#39;I am myObject.foo&amp;#39;を出力 sayFoo(); // sayFoo()内でのthisはグローバルオブジェクトなので&amp;#39;foo&amp;#39;を出力 (P.87より引用)
定義時の&amp;rsquo;foo&#39;が常に出ると予想されるかもだが、実際は実行時のコンテキストに依存する。
無名関数の即時実行 (function(){ console.log(&amp;#39;hoge&amp;#39;); })() functionの中身を即実行する書き方。 何度かこんなコードみたことあったのに、意味理解できていなかった。。
関数の巻き上げ function後ろのほうで定義、前のほうで実行でも問題なし。
foo() // -&amp;gt; hoge function foo() { console.</description>
    </item>
    
    <item>
      <title>Spring Fest 2019 参加レポート</title>
      <link>https://blog.abekoh.dev/post/spring-fest-2019/</link>
      <pubDate>Mon, 30 Dec 2019 02:05:02 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/spring-fest-2019/</guid>
      <description>12/18に開催されたSpring Fest 2019に参加してきました。 その時聞いたものについてのレポートです。
基調講演：From Spring Boot 2.2 to Spring Boot 2.3 スライド
Spring Boot 2.2での目玉機能、2.3で追加される予定のもの、Spring Cloudについての紹介でした。 気になったものいくつか取り上げます。
Health Indicator Group ヘルスチェックのエンドポイントを複数、グループ別で設定できる機能。
management.endpoint.health.group.liveness.include=ping management.endpoint.health.group.readiness.include=db,redis ↑の設定の場合、 /actguator/health/livenessと/actuator/health/redinessが提供される。
サンプルの設定どおり、KubernetesのLiveness/Readiness Probeと相性よさげ。
Immutable Configuration Properties コンストラクタインジェクションでCongiurationPropertiesが設定可能に。 →Setter不要。
またKotlinだとdata classにも適用できるとか。
GraalVM Javaだけどネイティブアプリ化させたりできるやつ。 昨年のSpring Festでは出たばっかりのころだったけど、順調にサポートが厚くなってきている感じ。
2020年に出るSpring 5.3になると、諸々設定が楽になるとのこと。
Cloud Native Buildpacks ソースコードを解析してOCI標準イメージを作成するツール。
(OCI標準イメージとは、Open Container Initiativeが定めた標準仕様に沿ったコンテナイメージのこと。 https://www.publickey1.jp/blog/17/open_container_initiativeoci_v10.html)
packというCLI使って簡単に試せる。
https://github.com/buildpacks/pack
特にKubernetes向けの場合、kpackというのも提供されている。 https://github.com/pivotal/kpack
Spring Boot爆速開発超絶技巧 スライド
ひたすらIntelliJのショートカット・機能を紹介していただくというセッション。 結構知らないショートカットもあって為になりました。
使えそうと思ったのが、breakpointのオプション。 「この条件に一致したらbreak」とか「breakせずにprintだけ行う」とかできる、知らなかった。。
LINE公式アカウントのチャットシステムにおけるSpringおよびWebFluxの活用事例 スライド
Spring WebFluxを実際にプロダクトに適用した事例紹介。
WebFluxを利用することで、各リクエストをノンブロッキングで処理することで、1つのイベントループスレッドで複数リクエストを捌けるようになる。そしてサーバー数が減少につながる。
実際うまく稼働できているとのこと。このあたり理解が浅いと感じたので、実際に触ってみようと思います。
NissanConnectの舞台裏で動くSpring Boot／Spring Cloud 〜Microserviceの実運用の事例〜 スライド</description>
    </item>
    
    <item>
      <title>Google API の OAuth 2.0トークン取得するツールつくった</title>
      <link>https://blog.abekoh.dev/post/get-google-token-with-go/</link>
      <pubDate>Sat, 21 Dec 2019 13:52:48 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/get-google-token-with-go/</guid>
      <description>Google PhotosのAPIつかって自動アップロードするバッチつくってみたくて調べたところ、 GCPサービスみたくサービスアカウント使う、ってことはできないみたいだった
https://developers.google.com/photos/library/guides/authentication-authorization#service-accounts
OAuth 2.0の認証フローをたどる必要があるみたい。
とはいえバッチつくるとき、初回のみ認証→次からはrefresh tokenで再利用という流れになるんだろうけど 初回のみ認証の実装をケチりたかったので、refresh token取得まで簡単に取得できるツールみたいなの書いてみた。
abekoh/get-google-tokens
 GCPサイドバー-&amp;gt;APIとサービス-&amp;gt;認証情報 より、認証情報を作成-&amp;gt;OAuthクライアントID を選択 用途に応じた種類を選ぶ。任意の名前をつける。JS生成元・リダイレクトURIは http://localhost:8080 を指定  認証情報一覧から、ダウンロードボタンを押す。client_secret_XXX.apps.googleusercontent.com..jsonのようなjsonファイルが手に入る。 token取得ツールインストール  go get github.com/abekoh/get-google-tokens 次を実行。例では、Google Photos APIにアップロードする権限のみ。  get-google-tokens -json client_secret_XXX.apps.googleusercontent.com.json -scope https://www.googleapis.com/auth/photoslibrary.appendonly photoのスコープはここ参照 https://developers.google.com/photos/library/guides/authentication-authorization
実行するとURLが表示されるので、アクセス。そしてスコープを許可。「このアプリは確認されていません」と表示されても進める。 リダイレクトされてlocalhostに移った後、ターミナルのほうを確認。Access TokenとRefresh Tokenが表示されている。  仕組みとしては、リダイレクト時にURLパラメータにcode=と認証コードが入るので、 それをWebサーバで受け取って、チャンネル送信して、POSTリクエストでトークン取得するという流れ。
Go久しぶり書きましたが、こんな感じでWebサーバー立ち上げ簡単にできる点、CLI化も楽な点がよいですね。
参考  Google API OAuth2.0のアクセストークン&amp;amp;リフレッシュトークン取得手順 2017年2月版 - Qiita  </description>
    </item>
    
    <item>
      <title>Hugo, Github Pages, CircleCIつかってブログ構築</title>
      <link>https://blog.abekoh.dev/post/how-to-build-this-blog/</link>
      <pubDate>Sat, 14 Dec 2019 13:40:05 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/how-to-build-this-blog/</guid>
      <description>このブログの構築メモ。 やっぱりブログもGitHubで管理できたらいいなーと探したら、この組み合わせで簡単にいい感じにできそうだったのでやってみた。
Hugoとは https://gohugo.io/
Go製の静的サイト生成ツール。 とにかく簡単にブログがつくれる。ブログじゃなくてもポートフォリオサイトやOSSプロジェクトページなんかもいける。
Markdownでかけるのも嬉しい。非常にGitHubフレンドリーな感じ。
個人的に惜しいと思う点は、超スタンダードな感じのテーマの多くがGPLなところ。 編集中のはPrivateにする場合ここが引っかかってしまうので、なくなくそれらを弾いてテーマ選びました。
とりあえずこれを無編集で使ってます。
https://github.com/zwbetz-gh/vanilla-bootstrap-hugo-theme
→ これに変更しました https://github.com/achary/engimo
構成 Github Pagesの機能をつかって公開するんですが、Hugoのソース自体はPrivateで管理。 abekoh.github.ioにはCircleCIがmaster pushするだけ。
CircleCI選んだ理由は、とりあえず有名でモダンなやつ試したかったから。 最近だとGithub Actionsがよかったかな、と後から思ったけどまぁいいか。
CircleCI設定 hugoのビルドは、Orbがあったのでそれを使う。 Orbはビルド手順のテンプレートみたいなの。
https://circleci.com/orbs/registry/orb/circleci/hugo
その後、Github Pagesへのpushは手動で設定。 このあたり参考にさせていただきました。
 CircleCIでgithub pagesに自動デプロイする CircleCIでHugoを実行してGitHub Pagesにデプロイ  引っかかったのが、ssh鍵設定してもcloneできない問題。 こちら参考に、StrictHostKeyChecking=noにすれば解決しました。
最終的に.circleci/config.ymlはこんな感じ。 なれてきたらまた直していきたい。
version: 2.1 orbs: hugo: circleci/hugo@0.4.1 jobs: deploy: docker: - image: cibuilds/base steps: - add_ssh_keys: # CirlceCIのSSH Permissionsに設定したSSH Keyのfingerprintを設定 fingerprints: - &amp;#34;SO:ME:FIN:G:ER:PR:IN:T&amp;#34; # ビルドしたworkspaceをもってくる - attach_workspace: at: . - deploy: name: deploy to Github Pages command: | # ssh警告無視 echo &amp;#34;HostName github.</description>
    </item>
    
    <item>
      <title>[Qiita] Slackでスニペットを共有するためのVimプラグインつくってみた</title>
      <link>https://blog.abekoh.dev/post/qiita-snipslack-vim/</link>
      <pubDate>Wed, 11 Dec 2019 23:52:09 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/qiita-snipslack-vim/</guid>
      <description>以前Qiitaに投稿した記事の紹介。
記事: Slackでスニペットを共有するためのVimプラグインつくってみた
GitHub: abekoh/snipslack.vim
VimからSlackのスニペットに、お手軽にポストできるプラグインつくってみた記事です。
2018年の会社の新卒有志Advent Calendarに参加して書きました。
Vimmerとしては一度はプラグインつくってみたい、そんな意欲で書きました。
Vim Scriptにしっかり向き合えて楽しかった。正規表現とか結構独特。業務などに役立つかはさておき。
作ったものの、実は最近はあまり自分でも使っていない。。
社内独自のスニペットサービスが使い勝手優秀で、結局それに頼っています。</description>
    </item>
    
    <item>
      <title>ブログはじめました</title>
      <link>https://blog.abekoh.dev/post/start-blog/</link>
      <pubDate>Wed, 11 Dec 2019 00:48:56 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/post/start-blog/</guid>
      <description>技術ブログはじめました。
黙々と勉強しつつもアウトプットの機会もなく、なんだかもったいないと思いはじめまして、 今度こそと続けていきたい所存です。
このブログはHugoっていう静的ページエンジンでつくってみました。
すべてGithub上で解決するのは良いですね。
CI連携などもまぁいい感じに設定できたので、そのこともおいおい記そうかと思います。
どうぞよろしくお願いいたします。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://blog.abekoh.dev/about/</link>
      <pubDate>Sun, 08 Dec 2019 14:06:13 +0900</pubDate>
      
      <guid>https://blog.abekoh.dev/about/</guid>
      <description>Profile 名前: abekoh
福岡出身、東京在住。
某Web系企業で、Web広告関係のエンジニアやってます。
メインで扱う言語はJavaです。
学生時代は画像系の機械学習とかやってました。
特にGAN (Generative Adversarial Nets)に注力していました。
Topics 業務であつかうもの:
Java, Spring Boot, TypeScript, AngularJS, Kubernetes, Cloud Foundry, Kafka, Oracle Database, MySQL, IntelliJ IDEA
興味あるもの:
Go, Kotlin, DDD, Vim, GCP, 自作キーボード
Privacy Policy 当ブログでは、利用状況を把握するためにGoogle Analyticsを利用しております。Google AnalyticsはCookieを利用して利用者の情報を収集します。Google Analyticsにおいてデータが収集、処理される仕組みについては、こちらをご参照ください。</description>
    </item>
    
  </channel>
</rss>